<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Library</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Netflix Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #141414;
            color: #fff;
            min-height: 100vh;
        }

        .container { max-width: 100%; margin: 0; overflow: hidden; }

        header {
            background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%);
            padding: 20px 4%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        h1 { font-size: 1.8em; font-weight: 700; color: #e50914; }
        .subtitle { font-size: 0.9em; color: #808080; margin-top: 2px; }

        .config-toggle {
            background: transparent;
            border: 1px solid #808080;
            color: #808080;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .config-toggle:hover { color: #fff; border-color: #fff; }

        .config-section {
            padding: 0 4%;
            background: #181818;
            border-bottom: 1px solid transparent;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.35s ease, opacity 0.25s ease, border-color 0.2s;
        }
        .config-section.open {
            max-height: 320px;
            opacity: 1;
            padding: 20px 4%;
            margin-top: 80px;
            border-bottom-color: #333;
        }
        .config-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .config-section-header h3 { font-size: 1.1em; color: #fff; }
        .config-close {
            background: transparent;
            border: 1px solid #555;
            color: #808080;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }
        .config-close:hover { color: #fff; border-color: #808080; }

        .config-row { display: flex; gap: 15px; align-items: center; margin-bottom: 12px; }
        label { font-weight: 500; color: #808080; min-width: 100px; }
        input[type="text"] {
            flex: 1;
            padding: 10px 14px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
        }
        input[type="text"]:focus { outline: none; border-color: #e50914; }

        .button-group { display: flex; gap: 10px; margin-top: 15px; }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary { background: #e50914; color: white; }
        .btn-primary:hover { background: #f40612; }
        .btn-secondary { background: #333; color: white; }
        .btn-secondary:hover { background: #444; }

        .content { padding: 100px 4% 90px; }

        .video-player-section {
            margin-bottom: 40px;
            display: none;
        }
        .video-player-section.active { display: block; }
        .current-video-title { font-size: 1.4em; color: #fff; margin-bottom: 12px; font-weight: 600; }
        video { width: 100%; max-height: 70vh; background: #000; }

        .section-container { margin-bottom: 45px; }
        .section-header { margin-bottom: 16px; padding-left: 4px; }
        .section-title { font-size: 1.4em; font-weight: 600; color: #fff; }
        .section-subtitle { color: #808080; font-size: 0.9em; margin-top: 4px; }

        .video-row {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 8px 0 20px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        .video-row::-webkit-scrollbar { height: 8px; }
        .video-row::-webkit-scrollbar-track { background: #333; border-radius: 4px; }
        .video-row::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }

        .video-grid { display: flex; gap: 8px; flex-wrap: nowrap; }
        .video-grid-library {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            padding: 8px 0 20px;
        }

        .video-card {
            position: relative;
            flex: 0 0 240px;
            cursor: pointer;
            transition: transform 0.2s ease, z-index 0.2s;
            border-radius: 4px;
            overflow: hidden;
        }
        .video-card:hover {
            transform: scale(1.08);
            z-index: 10;
        }
        .video-grid-library .video-card {
            flex: none;
            width: 100%;
        }

        .video-card-poster {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            background: #333;
            overflow: hidden;
        }
        .video-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        .video-card:hover .video-card-poster { box-shadow: 0 4px 20px rgba(0,0,0,0.6); }

        .video-card-info {
            padding: 12px 8px 0;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.9));
            opacity: 0;
            transition: opacity 0.2s;
        }
        .video-card:hover .video-card-info { opacity: 1; }
        .video-title { font-size: 0.95em; font-weight: 600; color: #fff; }
        .video-link { display: none; }

        .progress-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.95));
            padding: 20px 12px 12px;
        }
        .progress-bar-container {
            width: 100%;
            height: 4px;
            background: #555;
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 6px;
        }
        .progress-bar { height: 100%; background: #e50914; transition: width 0.3s; }
        .progress-text { color: #b3b3b3; font-size: 0.8em; }
        .progress-percentage { color: #e50914; font-weight: 600; }

        .continue-watching-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #e50914;
            color: white;
            padding: 4px 10px;
            border-radius: 2px;
            font-size: 0.7em;
            font-weight: 600;
        }

        .loading { text-align: center; padding: 60px; color: #808080; font-size: 1.1em; }
        .error { background: rgba(229,9,20,0.2); color: #ff6b6b; padding: 16px; border-radius: 4px; margin: 20px 0; border: 1px solid #e50914; }
        .success { background: rgba(0,255,0,0.1); color: #46d369; padding: 16px; border-radius: 4px; margin: 20px 0; border: 1px solid #46d369; }
        .empty-state { text-align: center; padding: 80px 20px; color: #808080; }
        .empty-state-icon { font-size: 4em; margin-bottom: 20px; opacity: 0.5; }

        .status-ribbon {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #181818;
            color: #b3b3b3;
            padding: 10px 20px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-label {
            color: #a0aec0;
            font-weight: 600;
        }

        .status-value {
            color: #48bb78;
            font-weight: 700;
        }

        .status-endpoint {
            color: #63b3ed;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .status-separator {
            color: #4a5568;
            font-weight: 300;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        .status-indicator.idle {
            background: #718096;
            animation: none;
        }

        .status-indicator.error {
            background: #f56565;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .response-time-good {
            color: #48bb78;
        }

        .response-time-medium {
            color: #ed8936;
        }

        .response-time-slow {
            color: #f56565;
        }

        .status-operation {
            color: #90cdf4;
            font-style: italic;
        }

        @media (max-width: 1200px) {
            .video-grid-library { grid-template-columns: repeat(3, 1fr); }
        }
        @media (max-width: 768px) {
            .video-card { flex: 0 0 160px; }
            .video-grid-library { grid-template-columns: repeat(2, 1fr); gap: 12px; }
            .config-row { flex-direction: column; align-items: stretch; }
            label { min-width: auto; }
            .section-title { font-size: 1.3em; }
            .status-ribbon { font-size: 0.7em; padding: 8px 10px; gap: 8px; }
            .status-endpoint { max-width: 150px; }
            .status-separator { display: none; }
            .status-item { gap: 5px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <h1>Video Library</h1>
                <p class="subtitle">Browse and play your video collection</p>
            </div>
            <button class="config-toggle" id="configToggle" onclick="toggleConfig()">âš™ Settings</button>
        </header>

        <div class="config-section" id="configSection">
            <div class="config-section-header">
                <h3>Configuration</h3>
                <button class="config-close" onclick="hideConfig()">âœ• Close</button>
            </div>
            <div class="config-row">
                <label for="apiEndpoint">API Endpoint:</label>
                <input type="text" id="apiEndpoint" placeholder="https://your-api-gateway.execute-api.region.amazonaws.com/prod">
            </div>
            <div class="config-row">
                <label for="primaryKey">Primary Key:</label>
                <input type="text" id="primaryKey" placeholder="Library" value="Library">
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="loadVideos()">Load Videos</button>
                <button class="btn-primary" onclick="loadVideos()" style="background: #28a745; margin-left: 10px;">
                    ðŸ”„ Refresh
                </button>
                <button class="btn-secondary" onclick="saveConfig()">Save Configuration</button>
            </div>
            <div id="message"></div>
        </div>

        <div class="content">
            <div id="videoPlayerSection" class="video-player-section">
                <div class="current-video-title" id="currentVideoTitle"></div>
                <video id="videoPlayer" controls>
                    Your browser does not support the video element.
                </video>
            </div>

            <div id="loading" class="loading" style="display: none;">
                Loading videos...
            </div>

            <!-- Continue Watching Section -->
            <div id="continueWatchingSection" class="section-container" style="display: none;">
                <div class="section-header">
                    <h2 class="section-title">Continue Watching</h2>
                    <p class="section-subtitle">Pick up where you left off</p>
                </div>
                <div class="video-row"><div id="continueWatchingList" class="video-grid"></div></div>
            </div>

            <!-- Library Section -->
            <div id="librarySection" class="section-container">
                <div class="section-header">
                    <h2 class="section-title">Library</h2>
                    <p class="section-subtitle">All available videos</p>
                </div>
                <div id="videoList" class="video-grid-library"></div>
            </div>

            <div id="emptyState" class="empty-state" style="display: none;">
                <div class="empty-state-icon">ðŸ“¹</div>
                <h2>No Videos Yet</h2>
                <p>Configure your API endpoint and load videos to get started</p>
            </div>
        </div>

        <!-- Status Ribbon -->
        <div class="status-ribbon">
            <div class="status-item">
                <div class="status-indicator idle" id="statusIndicator"></div>
                <span class="status-label">API:</span>
                <span class="status-endpoint" id="statusEndpoint">Not configured</span>
            </div>
            <div class="status-item">
                <span class="status-separator">|</span>
                <span class="status-label">Last Operation:</span>
                <span class="status-operation" id="lastOperation">None</span>
            </div>
            <div class="status-item">
                <span class="status-separator">|</span>
                <span class="status-label">Response Time:</span>
                <span class="status-value" id="responseTime">--</span>
            </div>
            <div class="status-item">
                <span class="status-separator">|</span>
                <span class="status-label">Total Requests:</span>
                <span class="status-value" id="totalRequests">0</span>
            </div>
            <div class="status-item">
                <span class="status-separator">|</span>
                <span class="status-label">Avg Response:</span>
                <span class="status-value" id="avgResponse">--</span>
            </div>
            <div class="status-item">
                <span class="status-separator">|</span>
                <span class="status-label">Backend:</span>
                <span class="status-value" id="statusBackend">--</span>
            </div>
            <div class="status-item">
                <span class="status-separator">|</span>
                <span class="status-label">Table:</span>
                <span class="status-value" id="statusTable">--</span>
            </div>
        </div>
    </div>

    <script>
        // Global variables for progress tracking
        let progressUpdateInterval = null;
        let currentVideoId = null;
        let currentUserId = null;
        let cachedVideos = [];

        // API monitoring variables
        let totalRequests = 0;
        let totalResponseTime = 0;
        let responseTimes = [];

        // Load saved configuration on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadConfig();
            initializeUserId();
            updateStatusRibbon();
        });

        function initializeUserId() {
            // Get or create a unique user ID for tracking
            currentUserId = localStorage.getItem('userId');
            if (!currentUserId) {
                currentUserId = 'user-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('userId', currentUserId);
            }
        }

        async function updateStatusRibbon() {
            const apiEndpoint = document.getElementById('apiEndpoint').value.trim();
            const statusEndpointEl = document.getElementById('statusEndpoint');
            const statusBackendEl = document.getElementById('statusBackend');
            const statusTableEl = document.getElementById('statusTable');

            if (apiEndpoint) {
                try {
                    const url = new URL(apiEndpoint);
                    statusEndpointEl.textContent = `${url.hostname}${url.pathname}`;
                    statusEndpointEl.title = apiEndpoint;
                } catch (e) {
                    statusEndpointEl.textContent = apiEndpoint;
                }
                // Fetch backend and table from API
                try {
                    const res = await fetch(`${apiEndpoint}/config`);
                    if (res.ok) {
                        const cfg = await res.json();
                        statusBackendEl.textContent = cfg.backend || '--';
                        statusTableEl.textContent = cfg.tableName || '--';
                    } else {
                        statusBackendEl.textContent = '--';
                        statusTableEl.textContent = '--';
                    }
                } catch (e) {
                    statusBackendEl.textContent = '--';
                    statusTableEl.textContent = '--';
                }
            } else {
                statusEndpointEl.textContent = 'Not configured';
                statusBackendEl.textContent = '--';
                statusTableEl.textContent = '--';
            }
        }

        function updateStatusIndicator(status) {
            const indicator = document.getElementById('statusIndicator');
            indicator.className = 'status-indicator ' + status; // idle, active, error
        }

        function logApiCall(operation, responseTimeMs, success = true) {
            totalRequests++;
            totalResponseTime += responseTimeMs;
            responseTimes.push(responseTimeMs);
            
            // Keep only last 100 response times for average calculation
            if (responseTimes.length > 100) {
                responseTimes.shift();
            }
            
            // Update UI
            document.getElementById('lastOperation').textContent = operation;
            document.getElementById('totalRequests').textContent = totalRequests;
            
            // Format response time with color coding
            const responseTimeEl = document.getElementById('responseTime');
            responseTimeEl.textContent = `${responseTimeMs}ms`;
            
            // Color code based on response time
            responseTimeEl.className = 'status-value';
            if (responseTimeMs < 200) {
                responseTimeEl.classList.add('response-time-good');
            } else if (responseTimeMs < 500) {
                responseTimeEl.classList.add('response-time-medium');
            } else {
                responseTimeEl.classList.add('response-time-slow');
            }
            
            // Calculate and display average
            const avgTime = Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length);
            const avgResponseEl = document.getElementById('avgResponse');
            avgResponseEl.textContent = `${avgTime}ms`;
            
            if (avgTime < 200) {
                avgResponseEl.className = 'status-value response-time-good';
            } else if (avgTime < 500) {
                avgResponseEl.className = 'status-value response-time-medium';
            } else {
                avgResponseEl.className = 'status-value response-time-slow';
            }
            
            // Update status indicator
            if (success) {
                updateStatusIndicator('');
                setTimeout(() => updateStatusIndicator('idle'), 1000);
            } else {
                updateStatusIndicator('error');
                setTimeout(() => updateStatusIndicator('idle'), 2000);
            }
        }

        async function apiCall(url, options = {}, operation = 'API Call') {
            const startTime = performance.now();
            
            try {
                const response = await fetch(url, options);
                const endTime = performance.now();
                const responseTime = Math.round(endTime - startTime);
                
                logApiCall(operation, responseTime, response.ok);
                
                return response;
            } catch (error) {
                const endTime = performance.now();
                const responseTime = Math.round(endTime - startTime);
                
                logApiCall(operation + ' (ERROR)', responseTime, false);
                
                throw error;
            }
        }

        function loadConfig() {
            const savedEndpoint = localStorage.getItem('apiEndpoint');
            const savedPrimaryKey = localStorage.getItem('primaryKey');

            if (savedEndpoint) {
                document.getElementById('apiEndpoint').value = savedEndpoint;
            }
            if (savedPrimaryKey) {
                document.getElementById('primaryKey').value = savedPrimaryKey;
            }
        }

        function toggleConfig() {
            const section = document.getElementById('configSection');
            const btn = document.getElementById('configToggle');
            section.classList.toggle('open');
            btn.textContent = section.classList.contains('open') ? 'â–¼ Hide Settings' : 'âš™ Settings';
        }

        function hideConfig() {
            document.getElementById('configSection').classList.remove('open');
            document.getElementById('configToggle').textContent = 'âš™ Settings';
        }

        function saveConfig() {
            const apiEndpoint = document.getElementById('apiEndpoint').value;
            const primaryKey = document.getElementById('primaryKey').value;

            localStorage.setItem('apiEndpoint', apiEndpoint);
            localStorage.setItem('primaryKey', primaryKey);

            updateStatusRibbon();
            showMessage('Configuration saved successfully!', 'success');

            hideConfig();
        }

        function showMessage(message, type = 'error') {
            const messageDiv = document.getElementById('message');
            messageDiv.className = type;
            messageDiv.textContent = message;
            messageDiv.style.display = 'block';
            
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 5000);
        }

        async function loadVideos() {
            const apiEndpoint = document.getElementById('apiEndpoint').value.trim();
            const primaryKey = document.getElementById('primaryKey').value.trim();
            
            if (!apiEndpoint) {
                showMessage('Please enter an API endpoint', 'error');
                return;
            }
            
            if (!primaryKey) {
                showMessage('Please enter a primary key value', 'error');
                return;
            }
            
            // Show loading state
            document.getElementById('loading').style.display = 'block';
            document.getElementById('videoList').innerHTML = '';
            document.getElementById('continueWatchingList').innerHTML = '';
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('continueWatchingSection').style.display = 'none';
            
            try {
                // Construct URL and log it
                const scanUrl = `${apiEndpoint}/scan?pk=${encodeURIComponent(primaryKey)}`;
                console.log('Attempting to fetch from:', scanUrl);
                
                // Try SCAN endpoint first
                let response;
                try {
                    response = await apiCall(scanUrl, {}, 'SCAN videos');
                    console.log('SCAN response status:', response.status);
                } catch (scanError) {
                    console.error('SCAN endpoint error:', scanError);
                    console.log('Trying GET endpoint as fallback...');
                    
                    // If SCAN fails, try GET endpoint
                    const getUrl = `${apiEndpoint}/videos?pk=${encodeURIComponent(primaryKey)}`;
                    console.log('Attempting GET from:', getUrl);
                    response = await apiCall(getUrl, {}, 'GET videos');
                    console.log('GET response status:', response.status);
                }
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response not OK:', response.status, errorText);
                    throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('Received data:', data);
                
                // Handle different response formats
                let videos = [];
                if (Array.isArray(data)) {
                    videos = data;
                } else if (data.items && Array.isArray(data.items)) {
                    videos = data.items;
                } else if (data.Items && Array.isArray(data.Items)) {
                    videos = data.Items;
                }
                
                console.log('Parsed videos count:', videos.length);
                
                if (videos.length === 0) {
                    showMessage('No videos found. Check your primary key or add videos to DynamoDB.', 'error');
                    document.getElementById('emptyState').style.display = 'block';
                    return;
                }
                
                // Fetch progress for all videos
                await loadProgressForVideos(videos);

                // Refresh backend/table in status ribbon
                updateStatusRibbon();

            } catch (error) {
                console.error('Error loading videos:', error);
                
                // Provide detailed error message
                let errorMessage = 'Failed to load videos: ';
                if (error.message.includes('Failed to fetch')) {
                    errorMessage += 'Network error. Check: (1) API endpoint URL is correct, (2) API Gateway is deployed, (3) CORS is enabled, (4) Your internet connection.';
                } else if (error.message.includes('500')) {
                    errorMessage += 'Server error. Check Lambda function logs in CloudWatch.';
                } else if (error.message.includes('403') || error.message.includes('401')) {
                    errorMessage += 'Access denied. Check API Gateway permissions.';
                } else if (error.message.includes('404')) {
                    errorMessage += 'Endpoint not found. Verify the API Gateway URL is correct.';
                } else {
                    errorMessage += error.message;
                }
                
                showMessage(errorMessage, 'error');
                document.getElementById('emptyState').style.display = 'block';
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        async function loadProgressForVideos(videos) {
            if (!videos || videos.length === 0) {
                document.getElementById('emptyState').style.display = 'block';
                return;
            }
            
            console.log('Loading progress for', videos.length, 'videos');
            
            const apiEndpoint = document.getElementById('apiEndpoint').value.trim();
            const continueWatching = [];
            const libraryVideos = [];
            
            // Fetch progress for each video
            for (const video of videos) {
                // UPDATED: Use sk as videoId
                const videoId = video.sk || video.Sk || video.videoId || video.VideoId || video.id || video.Id || '';
                
                if (videoId) {
                    try {
                        const progressUrl = `${apiEndpoint}/progress?userId=${encodeURIComponent(currentUserId)}&videoId=${encodeURIComponent(videoId)}`;
                        const response = await apiCall(progressUrl, {}, `GET progress [${videoId}]`);
                        
                        if (response.ok) {
                            const progressData = await response.json();
                            console.log(`Video ${videoId} progress:`, progressData);
                            
                            video.progressData = progressData;
                            const currentTime = Number(progressData?.currentTime) || 0;
                            const completed = Boolean(progressData?.completed);

                            if (currentTime > 0 && !completed) {
                                console.log(`âœ“ Adding ${videoId} to Continue Watching (time: ${currentTime})`);
                                continueWatching.push(video);
                            }
                        } else {
                            video.progressData = { currentTime: 0, completed: false };
                        }
                    } catch (error) {
                        console.error(`Error fetching progress for ${videoId}:`, error);
                        video.progressData = { currentTime: 0, completed: false };
                    }
                } else {
                    video.progressData = { currentTime: 0, completed: false };
                }
                
                // All videos go to library
                libraryVideos.push(video);
            }
            
            console.log('Continue Watching videos:', continueWatching.length);
            console.log('Library videos:', libraryVideos.length);
            
            // Display Continue Watching section if there are videos in progress
            const continueWatchingSection = document.getElementById('continueWatchingSection');
            if (continueWatching.length > 0) {
                console.log('âœ“ Showing Continue Watching section with', continueWatching.length, 'videos');
                continueWatchingSection.style.display = 'block';
                displayContinueWatching(continueWatching);
            } else {
                console.log('âœ— No videos in Continue Watching, section hidden');
                continueWatchingSection.style.display = 'none';
            }
            
            // Display all videos in library
            displayLibrary(libraryVideos);

            cachedVideos = libraryVideos;
        }

        async function refreshContinueWatching() {
            if (!cachedVideos || cachedVideos.length === 0) return;
            const apiEndpoint = document.getElementById('apiEndpoint').value.trim();
            if (!apiEndpoint) return;

            const continueWatching = [];
            for (const video of cachedVideos) {
                const videoId = video.sk || video.Sk || video.videoId || video.VideoId || video.id || video.Id || '';
                if (!videoId) continue;
                try {
                    const res = await apiCall(`${apiEndpoint}/progress?userId=${encodeURIComponent(currentUserId)}&videoId=${encodeURIComponent(videoId)}`, {}, `GET progress [${videoId}]`);
                    if (res.ok) {
                        const progressData = await res.json();
                        video.progressData = progressData;
                        const ct = Number(progressData?.currentTime) || 0;
                        if (ct > 0 && !Boolean(progressData?.completed)) continueWatching.push(video);
                    } else {
                        video.progressData = { currentTime: 0, completed: false };
                    }
                } catch (e) {
                    video.progressData = { currentTime: 0, completed: false };
                }
            }

            const section = document.getElementById('continueWatchingSection');
            if (continueWatching.length > 0) {
                section.style.display = 'block';
                displayContinueWatching(continueWatching);
            } else {
                section.style.display = 'none';
            }
            displayLibrary(cachedVideos);
        }

        function displayContinueWatching(videos) {
            const continueWatchingList = document.getElementById('continueWatchingList');
            continueWatchingList.innerHTML = '';
            
            // Sort by most recently watched
            videos.sort((a, b) => {
                const timeA = a.progressData?.lastUpdated || a.progressData?.timestamp || '';
                const timeB = b.progressData?.lastUpdated || b.progressData?.timestamp || '';
                return timeB.localeCompare(timeA);
            });
            
            videos.forEach(video => {
                const videoCard = createVideoCardWithProgress(video, true);
                continueWatchingList.appendChild(videoCard);
            });
        }

        function displayLibrary(videos) {
            const videoList = document.getElementById('videoList');
            videoList.innerHTML = '';
            
            videos.forEach(video => {
                const videoCard = createVideoCardWithProgress(video, false);
                videoList.appendChild(videoCard);
            });
        }

        function createVideoCardWithProgress(video, isContinueWatching) {
            const card = document.createElement('div');
            card.className = 'video-card';
            
            // Handle different possible field names - UPDATED FOR pk/sk SCHEMA
            const title = video.title || video.Title || video.name || video.Name || 'Untitled Video';
            const link = video.video || video.link || video.Link || video.url || video.URL || video.videoUrl || '';
            const videoId = video.sk || video.videoId || video.VideoId || video.id || video.Id || '';
            const duration = video.duration || video.Duration || '';
            const thumb = video.thumb || video.thumbnail || video.Thumbnail || '';
            
            // Get progress data
            const progressData = video.progressData || {};
            const currentTime = progressData.currentTime || 0;
            const completed = progressData.completed || false;
            
            // Calculate progress percentage (estimate duration if not provided)
            let progressPercentage = 0;
            let estimatedDuration = 0;
            
            if (duration) {
                // Parse duration string (e.g., "10:25" or "1:30:45")
                const parts = duration.split(':').map(p => parseInt(p));
                if (parts.length === 2) {
                    estimatedDuration = parts[0] * 60 + parts[1]; // MM:SS
                } else if (parts.length === 3) {
                    estimatedDuration = parts[0] * 3600 + parts[1] * 60 + parts[2]; // HH:MM:SS
                }
            }
            
            if (estimatedDuration > 0 && currentTime > 0) {
                progressPercentage = Math.min((currentTime / estimatedDuration) * 100, 100);
            } else if (currentTime > 0) {
                // If no duration, show that there is progress
                progressPercentage = 15; // Show some progress
            }
            
            let posterContent = '';
            if (thumb) {
                posterContent = `<img src="${escapeHtml(thumb)}" alt="${escapeHtml(title)}" class="video-thumbnail" onerror="this.style.display='none'">`;
            } else {
                posterContent = `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#333;color:#808080;font-size:0.9em">${escapeHtml(title)}</div>`;
            }
            if (isContinueWatching && currentTime > 0 && !completed) {
                posterContent += `<div class="continue-watching-badge">â–¶ Resume</div>`;
            }
            if (currentTime > 0 && !completed) {
                const timeStr = formatTime(currentTime);
                const durationStr = estimatedDuration > 0 ? formatTime(estimatedDuration) : '';
                posterContent += `
                    <div class="progress-indicator">
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${progressPercentage}%"></div>
                        </div>
                        <div class="progress-text">
                            <span>Resume at ${timeStr}</span>
                            ${durationStr ? `<span class="progress-percentage">${Math.round(progressPercentage)}%</span>` : ''}
                        </div>
                    </div>`;
            }
            card.innerHTML = `
                <div class="video-card-poster">${posterContent}</div>
                <div class="video-card-info">
                    <div class="video-title">${escapeHtml(title)}</div>
                </div>`;
            card.onclick = () => playVideo(title, link, videoId);
            
            return card;
        }

        // Keep the old function for backwards compatibility
        function createVideoCard(video) {
            return createVideoCardWithProgress(video, false);
        }

        function playVideo(title, url, videoId) {
            if (!url) {
                showMessage('No video URL available', 'error');
                return;
            }
            
            const videoPlayer = document.getElementById('videoPlayer');
            const videoPlayerSection = document.getElementById('videoPlayerSection');
            const currentVideoTitle = document.getElementById('currentVideoTitle');
            
            stopProgressTracking();
            currentVideoId = videoId;
            currentVideoTitle.textContent = title;
            videoPlayer.src = url;
            videoPlayerSection.classList.add('active');
            videoPlayerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            loadVideoProgress(videoId).then(savedTime => {
                if (savedTime && savedTime > 0) {
                    videoPlayer.currentTime = savedTime;
                    showMessage(`Resuming from ${formatTime(savedTime)}`, 'success');
                }
            });
            
            setupProgressTracking(videoPlayer);
            
            refreshContinueWatching();
            
            videoPlayer.play().catch(error => {
                console.error('Error playing video:', error);
                showMessage('Unable to play video. Please check the video URL.', 'error');
            });
        }

        function setupProgressTracking(videoPlayer) {
            // Start tracking when video starts playing
            videoPlayer.addEventListener('play', startProgressTracking);
            
            // Stop tracking when video is paused
            videoPlayer.addEventListener('pause', stopProgressTracking);
            
            // Stop tracking when video ends
            videoPlayer.addEventListener('ended', () => {
                stopProgressTracking();
                // Mark video as completed
                saveVideoProgress(currentVideoId, videoPlayer.duration, true);
            });
            
            // Save progress when user seeks
            videoPlayer.addEventListener('seeked', () => {
                if (currentVideoId) {
                    saveVideoProgress(currentVideoId, videoPlayer.currentTime, false);
                }
            });
        }

        function startProgressTracking() {
            if (progressUpdateInterval) clearInterval(progressUpdateInterval);
            const videoPlayer = document.getElementById('videoPlayer');
            
            progressUpdateInterval = setInterval(() => {
                if (currentVideoId && !videoPlayer.paused && !videoPlayer.ended) {
                    const currentTime = videoPlayer.currentTime;
                    const duration = videoPlayer.duration;
                    const percentComplete = (currentTime / duration) * 100;
                    console.log(`Saving progress: ${formatTime(currentTime)} / ${formatTime(duration)} (${percentComplete.toFixed(1)}%)`);
                    saveVideoProgress(currentVideoId, currentTime, false);
                }
            }, 3000);

            setTimeout(() => refreshContinueWatching(), 4000);
        }

        function stopProgressTracking() {
            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
                progressUpdateInterval = null;
            }
        }

        async function saveVideoProgress(videoId, currentTime, completed = false) {
            const apiEndpoint = document.getElementById('apiEndpoint').value.trim();
            
            if (!apiEndpoint || !videoId) {
                console.log('Cannot save progress: missing API endpoint or videoId');
                return;
            }
            
            console.log(`Saving progress for video ${videoId}: time=${currentTime.toFixed(1)}s, completed=${completed}`);
            
            try {
                const progressUrl = `${apiEndpoint}/progress`;
                const progressData = {
                    userId: currentUserId,
                    videoId: videoId,
                    currentTime: currentTime,
                    timestamp: new Date().toISOString(),
                    completed: completed
                };
                
                const response = await apiCall(progressUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(progressData)
                }, `POST progress [${videoId}]`);
                
                if (!response.ok) {
                    console.error('Failed to save progress:', response.status);
                } else {
                    console.log(`âœ“ Progress saved successfully for ${videoId}`);
                    if (completed) {
                        // If video completed, reload the page to update sections
                        showMessage('Video completed! Updating library...', 'success');
                        setTimeout(() => loadVideos(), 2000);
                    }
                }
            } catch (error) {
                console.error('Error saving progress:', error);
                // Don't show error to user to avoid disrupting viewing experience
            }
        }

        async function loadVideoProgress(videoId) {
            const apiEndpoint = document.getElementById('apiEndpoint').value.trim();
            
            if (!apiEndpoint || !videoId) {
                return 0;
            }
            
            try {
                const progressUrl = `${apiEndpoint}/progress?userId=${encodeURIComponent(currentUserId)}&videoId=${encodeURIComponent(videoId)}`;
                const response = await apiCall(progressUrl, {}, `GET progress [${videoId}]`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data && data.currentTime) {
                        return data.currentTime;
                    }
                }
            } catch (error) {
                console.error('Error loading progress:', error);
            }
            
            return 0;
        }

        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
